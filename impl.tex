\documentclass[index]{subfiles}
\begin{document}
\chapter{自动化设计系统的实现}\label{sec:impl}
本章将在\cref{sec:design}对系统的顶层设计的基础上，重点讨论每个组件的具体设计与实现细节，并介绍具体软件实现中所采用的技术栈。

对于较为大型的软件系统，除了开发系统本身以外，还需要单独开发另一套系统，用以对实际系统进行时时刻刻的监控，以方便运维人员应对可能出现的异常情况。
本章将先介绍自动化设计系统的本身（应用面，面向用户）的实现细节，再简要介绍内部监控系统（控制面，并不面向用户）的架构，
最后采用UML部署图画出整个系统的物理视图，讨论各个组件之间的通信方法，并描述整个系统的最终实现成果。

\section{应用面}
本节将就\cref{fig:design-comp}中的每个组件分别讨论技术栈选型和设计实现的全部细节。

在\cref{fig:design-comp}中，状态存储和消息队列两个组件和其他组件存在显著不同——它们都已经有了非常成熟的开源软件实现。
对于状态存储，本文选用开源分布式强一致性键值数据库etcd作为实现，其对外提供了读取、写入、擦除、监控修改等等一系列功能，
可以满足\cref{fig:design-comp}中对状态存储组件的要求。

对于消息队列，本文选用基于Erlang语言的开源分布式消息队列RabbitMQ作为实现，其遵守AMQP协议，且对外提供了队列运行监控功能。
通过将其内部结构配置成\cref{fig:design-comp-mq}所示的样子，就可以满足\cref{fig:design-comp}中对消息队列组件的要求。

\subsection{文件存储}
\begin{figure}[h]
  \centering
  \includegraphics{./figures/dist/impl-storage-usecase.pdf}
  \caption{文件存储组件的行为：UML用户用例图\label{fig:impl-storage-usecase}}
\end{figure}
\begin{figure}[h]
  \centering
  \includegraphics{./figures/dist/impl-storage-package.pdf}
  \caption{文件存储组件的结构：UML包图\label{fig:impl-storage-package}}
\end{figure}
通过将\cref{fig:design-comp}中对文件存储组件的要求细化，可以得到\cref{fig:impl-storage-usecase}。
具体来说，文件存储组件对外提供一套HTTP API，根据HTTP动词和URL来对硬盘上的指定资源进行指定操作，如上传、下载、移动等等。
之所以要区分两种不同的上传，是因为需要对用户上传的仿真源文件进行重命名，使得文件名相同的文件内容相同，文件名不同的文件文件内容不同，
以保证\cref{sec:design-wf}中提到的对Ansys结果的缓存可以正确工作。

本文选取JavaScript语言进行程序编写，目录结构如\cref{fig:impl-storage-package}所示，其中主要文件的功能如下：
\begin{description}
  \item[logger.js] 将日志信息汇总至Logstash（见\cref{sec:impl-elk}）
  \item[file/common.js] 判断文件名是否合法
  \item[file/get.js] 响应GET请求，实现文件下载、列出文件夹内容、打包下载文件夹
  \item[file/post.js] 响应POST请求，实现源文件上传、仿真结果上传
  \item[file/put.js] 响应PUT请求，方便调试时上传文件
  \item[utils/contentstream.js] 对HTTP PUT请求的内容进行解析
  \item[utils/disk.js] 对用户上传的仿真源文件进行重命名
\end{description}

\subsection{工作流内核}
\begin{figure}[h]
  \centering
  \includegraphics{./figures/dist/impl-controller-seq.pdf}
  \caption{工作流内核组件的行为：UML序列图\label{fig:impl-controller-seq}}
\end{figure}
\begin{figure}[h]
  \centering
  \includegraphics{./figures/dist/impl-controller-package.pdf}
  \caption{工作流内核组件的结构：UML包图\label{fig:impl-controller-package}}
\end{figure}
根据\cref{ssec:design-wf}中对工作流内核组件的描述，该组件虽然不对外提供服务，但内部却存在较为复杂的流程。
为此，采用UML序列图而非UML用户用例图来对该组件的行为进行建模。
\Cref{fig:impl-controller-seq}详细描述了工作流内核如何实现FL-Petri网的运行，其中的跳变表示FL-Petri网中的跳变，而非其翻译之后的L-Petri网的跳变。
解释器在收到消息队列中的外部事件（其中注明了应尝试启功哪个外部跳变）以后，首先会为本次消息处理创建一个运行环境。
运行环境中最重要的属性是Petri网名称（因为状态存储中不仅仅存储了一张Petri网）和当前跳变的层参数。
随后，解释器通过运行环境检查当前跳变的输入是否满足（正常情况下由外部事件直接触发的外部跳变的输入应该满足，否则多是因为网络抖动等原因导致同一任务有多个应答）。
若满足，则执行该外部跳变。在执行过程中，
可以对数据库中不涉及状态的字段进行读写，以保存中间结果以供后续使用；
可以向消息队列发布计算任务（对于简单的表达式计算，甚至可以直接发布计算结果）；
还可以调用运行环境中相应的方法来设置跳变的输出（位置和层参数）。
在跳变执行完毕以后，解释器检查运行环境中发生变化的F-Petri网位置，并尝试检查以之为输入的内部跳变的输入是否满足；
若满足，则执行那些内部跳变。重复以上过程，直至所有F-Petri网中的跳变均不满足输入条件。
最后，通知运行环境将上述所有修改批量写入数据库，并通知消息队列该事件已经妥善处理完毕。

需要注意的是，该工作流内核并不是一个完整的FL-Petri网的模拟器（甚至也不是完整的Petri网模拟器）：
\begin{itemize}
  \item 无法处理对于没有输入弧的内部跳变
  \item 无法处理多个内部跳变无限循环的情况
  \item 无法正确处理多个跳变完全竞争的情形（在实现中为了简单起见，名字靠前的跳变会被执行）
\end{itemize}
然而，这些缺陷并不影响其作为工作流引擎——在本文所述系统的工作流\cref{fig:design-petri1,fig:design-petri2}中，以上三种情况根本不存在。

本文选取JavaScript语言进行程序编写，目录结构如\cref{fig:impl-controller-package}所示，其中主要文件的功能如下：
\begin{description}
  \item[amqp.js] 消息队列驱动
  \item[etcd.js, adapter.js] 数据库驱动
  \item[core/global.js] 最外层的FL-Petri网跳变
  \item[core/category.js] 分类层的FL-Petri网跳变中的初始化和收尾部分
  \item[core/iter.js] 分类层的FL-Petri网跳变中的迭代部分
  \item[core/eval.js] 求值层和参数层的FL-Petri网跳变中的参数计算部分
  \item[core/ansys.js] 求值层的FL-Petri网跳变中的Ansys仿真部分
  \item[petri/index.js] FL-Petri网解释器
  \item[petri/path.js] 负责层参数的序列化和反序列化
  \item[petri/runtime.js] 运行环境
\end{description}

\subsection{计算服务}
\begin{figure}[h]
  \centering
  \includegraphics{./figures/dist/impl-commond-activity.pdf}
  \caption{计算服务组件的行为：UML活动图\label{fig:impl-commond-activity}}
\end{figure}
\begin{figure}[h]
  \centering
  \includegraphics{./figures/dist/impl-commond-package.pdf}
  \caption{计算服务组件的结构：UML包图\label{fig:impl-commond-package}}
\end{figure}
根据\cref{ssec:design-wf}中对计算服务组件的描述，该组件并不对外提供服务，且其内部流程也比较简单。
为此，采用UML活动图而非UML用户用例图或UML序列图来对该组件的行为进行建模，如\cref{fig:impl-commond-activity}所示。
需要注意的是，\cref{fig:impl-commond-activity}中只表明了如何处理Ansys仿真任务；
对于其他计算任务（Python、R、Mathematica等），基本流程几乎完全一致，只是少了下载仿真文件和上传仿真结果文件两步。

本文选取Go语言进行程序编写，包结构如\cref{fig:impl-commond-package}所示（python、rlang、mma、ansys四个包的内容几乎完全相同，故只画出一个），
其中主要文件和包的功能如下：
\begin{description}
  \item[commond-std] 将commond封装成可以独立运行的程序
  \item[commond-svc] 将commond封装成Windows服务，以便在Windows系统上长时间运行
  \item[common/util.go] 封装创建临时文件夹、实时监控日志文件、下载仿真文件、上传仿真结果文件、删除临时文件夹等功能
  \item[common/killer\_*.go] 结束进程树（分为Linux和Windows两个不同实现）
\end{description}

\subsection{网站后端}
% TODO
\subsection{网站前端}
% TODO
\subsection{前置代理}
% TODO

\section{控制面}\label{sec:impl-elk}
% TODO
\section{物理视图}
\begin{figure}[h]
  \centering
  \includegraphics{./figures/dist/impl-deploy.pdf}
  \caption{系统物理视图：UML部署图\label{fig:impl-deploy}}
\end{figure}
% TODO
\end{document}
